## 0. Tool 物件的關鍵屬性
| 屬性            | 型別                 | 說明                                            |
| ------------- | ------------------ | --------------------------------------------- |
| name          | 字串                 | 必須在提供給 LLM 或代理的一組工具中是唯一的。                     |
| description   | 字串                 | 描述這個工具的功能。作為 LLM 或代理的上下文使用。                   |
| args_schema   | Pydantic BaseModel | 選擇性但建議使用，可用於提供更多資訊（例如：少量範例）或對預期參數進行驗證。        |
| return_direct | 布林值                | 僅與代理相關。當設為 True 時，在調用給定工具後，代理會停止並直接將結果返回給使用者。 |
他的內部會長得像這樣
```json
{
  'description': '查詢台灣特定城市的天氣情況。\n\n參數:\ncity (str): 要查詢天氣的城市名稱，例如 "台北"、"高雄"  等。\ndate (str, 可選): 要查詢的日期，格式為 "YYYY-MM-DD"。如果不提供，則查詢當天天氣。\n\n返回:\nstr:  包含天氣信息的字符串。',
  'properties': {
    'city': {
      'title': 'City',
      'type': 'string'
    },
    'date': {
      'anyOf': [
        {
          'type': 'string'
        },
        {
          'type': 'null'
        }
      ],
      'default': None,
      'title': 'Date'
    }
  },
  'required': [
    'city'
  ],
  'title': 'query_taiwan_weather',
  'type': 'object'
}
```

而模型回傳時，會用這種方式來呼叫
```json
AIMessage(
    content='',
    additional_kwargs={
        'tool_calls': [
            {
                'id': 'call_GKYP99QQo84AvULJ7R6NuQUh',
                'function': {'arguments': '{"city":"台北","date":"2023-10-03"}', 'name': 'query_taiwan_weather'},
                'type': 'function'
            }
        ],
        'refusal': None
    },
    response_metadata={
        'token_usage': {
            'completion_tokens': 27,
            'prompt_tokens': 153,
            'total_tokens': 180,
            'completion_tokens_details': {
                'accepted_prediction_tokens': 0,
                'audio_tokens': 0,
                'reasoning_tokens': 0,
                'rejected_prediction_tokens': 0
            },
            'prompt_tokens_details': {'audio_tokens': 0, 'cached_tokens': 0}
        },
        'model_name': 'gpt-4o-mini-2024-07-18',
        'system_fingerprint': 'fp_6fc10e10eb',
        'finish_reason': 'tool_calls',
        'logprobs': None
    },
    id='run-723e50f3-7a24-4d8b-9057-b3a615a0969e-0',
    tool_calls=[
        {
            'name': 'query_taiwan_weather',
            'args': {'city': '台北', 'date': '2023-10-03'},
            'id': 'call_GKYP99QQo84AvULJ7R6NuQUh',
            'type': 'tool_call'
        }
    ],
    usage_metadata={
        'input_tokens': 153,
        'output_tokens': 27,
        'total_tokens': 180,
        'input_token_details': {'audio': 0, 'cache_read': 0},
        'output_token_details': {'audio': 0, 'reasoning': 0}
    }
)
```
## 1. 使用 @tool 從函數建立
### 1.1 基本用法
``` python
from langchain.tools import tool

@tool
def get_taiwan_weather(city: str) -> str:
	"""查詢台灣特定城市的天氣狀況。"""
	weather_data = {
	"台北": "晴天，溫度28°C",
	"台中": "多雲，溫度26°C",
	"高雄": "陰天，溫度30°C"
	}
	return f"{city}的天氣：{weather_data.get(city, '暫無資料')}"

# 檢視工具的相關屬性
print(f"name: {get_taiwan_weather.name}")
print(f"description: {get_taiwan_weather.description}")
print(f"args: {get_taiwan_weather.args}")

# 使用這個工具
result = get_taiwan_weather.run("台北")
print(f"呼叫工具結果{result}")
```


### 1.2 自定義工具名稱和參數
```python
from langchain.pydantic_v1 import BaseModel, Field

class TravelPlanInput(BaseModel):
	city: str = Field(description="欲訪問的台灣城市")
	days: int = Field(description="旅遊天數")
	budget: int = Field(description="預算（新台幣）")

  

@tool("台灣旅遊規劃器", args_schema=TravelPlanInput, return_direct=True)
def plan_taiwan_trip(city: str, days: int, budget: int) -> str:
	"""根據指定的城市、天數和預算規劃台灣旅遊行程。"""
	per_day_budget = budget // days
	if city == "台北":
		return f"台北{days}天行程：每天預算{per_day_budget}元。建議景點：101大樓、故宮博物院、象山。別忘了品嚐鼎泰豐的小籠包！"
	
	elif city == "台中":
		return f"台中{days}天行程：每天預算{per_day_budget}元。建議景點：高美濕地、彩虹眷村、逢甲夜市。記得嘗試太陽餅！"
	
	elif city == "高雄":
		return f"高雄{days}天行程：每天預算{per_day_budget}元。建議景點：蓮池潭、駁二藝術特區、旗津海岸。不要錯過壽山動物園！"
	
	else:
		return f"抱歉，目前沒有{city}的旅遊規劃資訊。"

  

print(plan_taiwan_trip.name)
print(plan_taiwan_trip.description)
print(plan_taiwan_trip.args)
print(plan_taiwan_trip.return_direct)

  

# 使用這個工具

result = plan_taiwan_trip.run({"city": "台北", "days": 3, "budget": 10000})
print(result)
```
- 使用 `.run()` 方法：當使用 @tool 裝飾器創建工具時，使用 `.run()` 方法來執行工具，而不是直接調用函數。
- 使用 @tool("台灣旅遊規劃器", ...) 來自訂工具名稱。
- 參數傳遞：定義了一個 TravelPlanInput 類來精確指定工具的輸入結構。
- 返回結果：`return_direct=True` 表示這個工具的輸出應該直接返回給用戶，而不需要進一步處理。

---

## 2. StructuredTool
### 2.1  基礎用法
`StructuredTool.from_function` 類方法提供了比 `@tool` 裝飾器更多的配置選項，同時不需要太多額外的程式碼。
```python
from langchain_core.tools import StructuredTool

def calculate_night_market_price(item: str, quantity: int) -> str:
	"""計算台灣夜市小吃的總價。"""
	prices = {
		"蚵仔煎": 60,
		"臭豆腐": 40,
		"珍珠奶茶": 50,
		"鹽酥雞": 70,
		"大腸包小腸": 55
	}
	
	if item not in prices:
		return f"抱歉，我們沒有 {item} 的價格信息。"
	total = prices[item] * quantity
	return f"{quantity} 份 {item} 的總價是 {total} 元新台幣。"
	
	  
	
async def acalculate_night_market_price(item: str, quantity: int) -> str:
	"""非同步計算台灣夜市小吃的總價。"""
	return calculate_night_market_price(item, quantity)
	
night_market_calculator = StructuredTool.from_function(
	func=calculate_night_market_price,
	coroutine=acalculate_night_market_price
)  

print(night_market_calculator.invoke({"item": "臭豆腐", "quantity": 2}))
print(await night_market_calculator.ainvoke({"item": "珍珠奶茶", "quantity": 3}))
```
1. 
### 2.2 優勢
- 可以同時建立同步（sync）和非同步（async）函數。
    - `func`: 指定同步函數 `calculate_night_market_price`。
    - `coroutine`: 指定非同步函數 `acalculate_night_market_price`。
- 這樣配置允許工具根據調用方式（`invoke` 或 `ainvoke`）自動選擇適當的函數。

### 2.3  進階用法
```python
from langchain.pydantic_v1 import BaseModel, Field

class NightMarketInput(BaseModel):
	item: str = Field(description="夜市小吃名稱，例如：蚵仔煎、臭豆腐、珍珠奶茶等")
	quantity: int = Field(description="購買數量")

  

def calculate_night_market_price(item: str, quantity: int) -> str:
	"""計算台灣夜市小吃的總價。"""

	prices = {
		"蚵仔煎": 60,
		"臭豆腐": 40,
		"珍珠奶茶": 50,
		"鹽酥雞": 70,
		"大腸包小腸": 55
	}

	if item not in prices:
		return f"抱歉，我們沒有 {item} 的價格信息。"
	total = prices[item] * quantity
	return f"{quantity} 份 {item} 的總價是 {total} 元新台幣。"

night_market_calculator = StructuredTool.from_function(
	func=calculate_night_market_price,
	name="台灣夜市小吃計價器",
	description="計算台灣夜市常見小吃的總價",
	args_schema=NightMarketInput,
	return_direct=True
)

print(night_market_calculator.invoke({"item": "蚵仔煎", "quantity": 2}))
print(night_market_calculator.name)
print(night_market_calculator.description)
print(night_market_calculator.args)
```


1. 定義輸入模型：
	NightMarketInput 使用 BaseModel 和 Field 定義了輸入參數的結構和描述。
	這有助於確保輸入的正確性，並為使用者提供清晰的指引。
2. 結構化輸入：通過定義明確的輸入模型，可以確保傳入的參數符合預期格式。
3. 彈性配置：相比 @tool 裝飾器，提供了更多的配置選項。
4. 同步與非同步支援：可以同時定義同步和非同步版本的函數。
5. 易於整合：可以輕鬆地與 LangChain 的其他組件（如 Agents）整合。
---
## 工具的錯誤處理
```python
from langchain_core.tools import ToolException
from langchain.tools import StructuredTool
````

### 3.1 設置 ToolException

並使用 `handle_tool_error` 來指定錯誤處理方式。

可以設置在這裡，該函數直接抱一個 ToolException：

```python
def get_weather(city: str) -> int:
    """查詢指定城市的天氣。"""
    raise ToolException(f"錯誤：找不到名為 {city} 的城市。")
```

### 3.2 使用 StructuredTool.from_function

```python
StructuredTool.from_function(
    func=get_weather,
    handle_tool_error=True,
)
```

也可以直接這樣：

```python
get_weather_tool = StructuredTool.from_function(
    func=get_weather,
    handle_tool_error="抱歉，找不到該城市，但那裡的溫度應該高於絕對零度！",
)

result = get_weather_tool.invoke({"city": "未知城市"})
print("自定義字串錯誤處理：", result)
```

### 3.3 使用自定義函數處理

```python
# 使用自定義錯誤處理函數
def custom_error_handler(error: ToolException) -> str:
    return f"工具執行期間發生以下錯誤：`{error.args[0]}`"

get_weather_tool = StructuredTool.from_function(
    func=get_weather,
    handle_tool_error=custom_error_handler,
)

result = get_weather_tool.invoke({"city": "未知城市"})
print("自定義函數錯誤處理：", result)
```