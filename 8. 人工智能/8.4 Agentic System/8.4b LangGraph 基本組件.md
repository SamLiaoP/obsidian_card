LangGraph 用有向圖（Directed Graph）來描述應用程式結構。想像將你的應用程式描述成一張有向圖。

他的組件有 
1. Node 
2. Edge
3. State

節點(Node) 都代表一個工作站，
邊(edge) 則是工作站之間傳遞資訊的通道。
state 則是消息共享中心
## **Node節點：**
工作站
可以用add_node方法加入到工作流程圖中：
  
```python

def function1(input_1):
  return input_1 + " Function1處理完畢"

def function2(input_2):
  return input_2 + " Function2處理完畢"

graph.add_node("node_1", function1)
graph.add_node("node_2", function2)

```

### *Chain*
一般來說，call model 的部分，會先用chain包起來，長得像這樣

``` python
from langchain_openai import ChatOpenAI
from langchain.prompts import ChatPromptTemplate

model = ChatOpenAI(temperature=0.4)
prompt_str = """
You are given one question and you have to extract city name from it
"""
prompt = ChatPromptTemplate.from_template(prompt_str)

# 這一步，是把 prompt 跟 model 組成 Chain 
chain = prompt | model
res = chain.invoke({"user_query": "請問高雄天氣如何?"})
res.content
```
再這樣包成 Node

```python

def call_model(state: AllState):
    messages = state["messages"]
    print("messages", messages)
    response = chain.invoke(messages)
    return {"messages": [response]}

```

## **Edge 邊：**
用來連接 Node 的傳送帶
#### *普通邊(simple Edge)*

```python

graph.add_edge('node_1', 'node_2')

```


####  *入口點(Entry Point)和終點(End Point)*

```python

from langgraph.graph import START
from langgraph.graph import END

graph.add_edge(START, "node_a")
graph.add_edge("node_2", END)

```

  

#### ***條件邊(Conditional Edge)***
有條件判斷來執行的邊

```python

def where_to_go(state):
  _# Your Logic here_
  if state['Condition']:
    return "end"
  else:
    return "continue"

  

# agent node is connected with 2 nodes END and weather_tool_

graph.add_conditional_edges('agent',where_to_go,{
    "end": END,
    "continue": "weather_tool"
})

```

  

####  ***狀態(state)：消息的共享中心***
在 LangGraph 中，狀態是捕獲應用程序當前快照的共享資料結構。它可以是任何 Python 類型,但通常是 TypedDict 或 Pydantic BaseModel。
狀態使節點能夠相互通信和交換訊息。

  
####  ***圖(Graph): LangGraph 的核心結構***
有兩種類型的圖可以在 LangGraph 中創建:
1. 基本圖(Basic Graph): 只能將一個節點的輸出傳遞給下一個節點。因為無法包含狀態
2. 有狀態圖圖(Stateful Graph): 可以包含在節點之間傳遞的狀態，並且可以在任何節點訪問此狀態。

這裡是如何定義狀態並將其傳遞給有狀態圖的範例:

```python
import operator
from typing import TypedDict, Annotated, List
from langgraph.graph import StateGraph

  
class AllState(TypedDict):
    messages: Annotated[list[str], operator.add]

graph = StateGraph(AllState)

```

  在這個例子中，我們使用 TypedDict 定義了一個包含 messages 鍵的字典。該鍵預期持有一個字符串列表。我們使用 operator.add 函數作為 reducer,這意味著當新消息被添加到列表時,它們將與現有消息組合。
  
LangGraph 的核心是將代理工作流程建模為圖，你可以制定你的 AI 代理行為，使用上面介紹的關鍵元素