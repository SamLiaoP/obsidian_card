{
  "file_id": "6a6d1532",
  "name": "8.4c Tool Calling.md",
  "path": "8. 人工智能/8.4 Agentic System/8.4c Tool Calling.md",
  "content": "## 0. Tool 物件的關鍵屬性\n| 屬性            | 型別                 | 說明                                            |\n| ------------- | ------------------ | --------------------------------------------- |\n| name          | 字串                 | 必須在提供給 LLM 或代理的一組工具中是唯一的。                     |\n| description   | 字串                 | 描述這個工具的功能。作為 LLM 或代理的上下文使用。                   |\n| args_schema   | Pydantic BaseModel | 選擇性但建議使用，可用於提供更多資訊（例如：少量範例）或對預期參數進行驗證。        |\n| return_direct | 布林值                | 僅與代理相關。當設為 True 時，在調用給定工具後，代理會停止並直接將結果返回給使用者。 |\n他的內部會長得像這樣\n```json\n{\n  'description': '查詢台灣特定城市的天氣情況。\\n\\n參數:\\ncity (str): 要查詢天氣的城市名稱，例如 \"台北\"、\"高雄\"  等。\\ndate (str, 可選): 要查詢的日期，格式為 \"YYYY-MM-DD\"。如果不提供，則查詢當天天氣。\\n\\n返回:\\nstr:  包含天氣信息的字符串。',\n  'properties': {\n    'city': {\n      'title': 'City',\n      'type': 'string'\n    },\n    'date': {\n      'anyOf': [\n        {\n          'type': 'string'\n        },\n        {\n          'type': 'null'\n        }\n      ],\n      'default': None,\n      'title': 'Date'\n    }\n  },\n  'required': [\n    'city'\n  ],\n  'title': 'query_taiwan_weather',\n  'type': 'object'\n}\n```\n\n而模型回傳時，會用這種方式來呼叫\n```json\nAIMessage(\n    content='',\n    additional_kwargs={\n        'tool_calls': [\n            {\n                'id': 'call_GKYP99QQo84AvULJ7R6NuQUh',\n                'function': {'arguments': '{\"city\":\"台北\",\"date\":\"2023-10-03\"}', 'name': 'query_taiwan_weather'},\n                'type': 'function'\n            }\n        ],\n        'refusal': None\n    },\n    response_metadata={\n        'token_usage': {\n            'completion_tokens': 27,\n            'prompt_tokens': 153,\n            'total_tokens': 180,\n            'completion_tokens_details': {\n                'accepted_prediction_tokens': 0,\n                'audio_tokens': 0,\n                'reasoning_tokens': 0,\n                'rejected_prediction_tokens': 0\n            },\n            'prompt_tokens_details': {'audio_tokens': 0, 'cached_tokens': 0}\n        },\n        'model_name': 'gpt-4o-mini-2024-07-18',\n        'system_fingerprint': 'fp_6fc10e10eb',\n        'finish_reason': 'tool_calls',\n        'logprobs': None\n    },\n    id='run-723e50f3-7a24-4d8b-9057-b3a615a0969e-0',\n    tool_calls=[\n        {\n            'name': 'query_taiwan_weather',\n            'args': {'city': '台北', 'date': '2023-10-03'},\n            'id': 'call_GKYP99QQo84AvULJ7R6NuQUh',\n            'type': 'tool_call'\n        }\n    ],\n    usage_metadata={\n        'input_tokens': 153,\n        'output_tokens': 27,\n        'total_tokens': 180,\n        'input_token_details': {'audio': 0, 'cache_read': 0},\n        'output_token_details': {'audio': 0, 'reasoning': 0}\n    }\n)\n```\n## 1. 使用 @tool 從函數建立\n### 1.1 基本用法\n``` python\nfrom langchain.tools import tool\n\n@tool\ndef get_taiwan_weather(city: str) -> str:\n\t\"\"\"查詢台灣特定城市的天氣狀況。\"\"\"\n\tweather_data = {\n\t\"台北\": \"晴天，溫度28°C\",\n\t\"台中\": \"多雲，溫度26°C\",\n\t\"高雄\": \"陰天，溫度30°C\"\n\t}\n\treturn f\"{city}的天氣：{weather_data.get(city, '暫無資料')}\"\n\n# 檢視工具的相關屬性\nprint(f\"name: {get_taiwan_weather.name}\")\nprint(f\"description: {get_taiwan_weather.description}\")\nprint(f\"args: {get_taiwan_weather.args}\")\n\n# 使用這個工具\nresult = get_taiwan_weather.run(\"台北\")\nprint(f\"呼叫工具結果{result}\")\n```\n\n\n### 1.2 自定義工具名稱和參數\n```python\nfrom langchain.pydantic_v1 import BaseModel, Field\n\nclass TravelPlanInput(BaseModel):\n\tcity: str = Field(description=\"欲訪問的台灣城市\")\n\tdays: int = Field(description=\"旅遊天數\")\n\tbudget: int = Field(description=\"預算（新台幣）\")\n\n  \n\n@tool(\"台灣旅遊規劃器\", args_schema=TravelPlanInput, return_direct=True)\ndef plan_taiwan_trip(city: str, days: int, budget: int) -> str:\n\t\"\"\"根據指定的城市、天數和預算規劃台灣旅遊行程。\"\"\"\n\tper_day_budget = budget // days\n\tif city == \"台北\":\n\t\treturn f\"台北{days}天行程：每天預算{per_day_budget}元。建議景點：101大樓、故宮博物院、象山。別忘了品嚐鼎泰豐的小籠包！\"\n\t\n\telif city == \"台中\":\n\t\treturn f\"台中{days}天行程：每天預算{per_day_budget}元。建議景點：高美濕地、彩虹眷村、逢甲夜市。記得嘗試太陽餅！\"\n\t\n\telif city == \"高雄\":\n\t\treturn f\"高雄{days}天行程：每天預算{per_day_budget}元。建議景點：蓮池潭、駁二藝術特區、旗津海岸。不要錯過壽山動物園！\"\n\t\n\telse:\n\t\treturn f\"抱歉，目前沒有{city}的旅遊規劃資訊。\"\n\n  \n\nprint(plan_taiwan_trip.name)\nprint(plan_taiwan_trip.description)\nprint(plan_taiwan_trip.args)\nprint(plan_taiwan_trip.return_direct)\n\n  \n\n# 使用這個工具\n\nresult = plan_taiwan_trip.run({\"city\": \"台北\", \"days\": 3, \"budget\": 10000})\nprint(result)\n```\n- 使用 `.run()` 方法：當使用 @tool 裝飾器創建工具時，使用 `.run()` 方法來執行工具，而不是直接調用函數。\n- 使用 @tool(\"台灣旅遊規劃器\", ...) 來自訂工具名稱。\n- 參數傳遞：定義了一個 TravelPlanInput 類來精確指定工具的輸入結構。\n- 返回結果：`return_direct=True` 表示這個工具的輸出應該直接返回給用戶，而不需要進一步處理。\n\n---\n\n## 2. StructuredTool\n### 2.1  基礎用法\n`StructuredTool.from_function` 類方法提供了比 `@tool` 裝飾器更多的配置選項，同時不需要太多額外的程式碼。\n```python\nfrom langchain_core.tools import StructuredTool\n\ndef calculate_night_market_price(item: str, quantity: int) -> str:\n\t\"\"\"計算台灣夜市小吃的總價。\"\"\"\n\tprices = {\n\t\t\"蚵仔煎\": 60,\n\t\t\"臭豆腐\": 40,\n\t\t\"珍珠奶茶\": 50,\n\t\t\"鹽酥雞\": 70,\n\t\t\"大腸包小腸\": 55\n\t}\n\t\n\tif item not in prices:\n\t\treturn f\"抱歉，我們沒有 {item} 的價格信息。\"\n\ttotal = prices[item] * quantity\n\treturn f\"{quantity} 份 {item} 的總價是 {total} 元新台幣。\"\n\t\n\t  \n\t\nasync def acalculate_night_market_price(item: str, quantity: int) -> str:\n\t\"\"\"非同步計算台灣夜市小吃的總價。\"\"\"\n\treturn calculate_night_market_price(item, quantity)\n\t\nnight_market_calculator = StructuredTool.from_function(\n\tfunc=calculate_night_market_price,\n\tcoroutine=acalculate_night_market_price\n)  \n\nprint(night_market_calculator.invoke({\"item\": \"臭豆腐\", \"quantity\": 2}))\nprint(await night_market_calculator.ainvoke({\"item\": \"珍珠奶茶\", \"quantity\": 3}))\n```\n1. \n### 2.2 優勢\n- 可以同時建立同步（sync）和非同步（async）函數。\n    - `func`: 指定同步函數 `calculate_night_market_price`。\n    - `coroutine`: 指定非同步函數 `acalculate_night_market_price`。\n- 這樣配置允許工具根據調用方式（`invoke` 或 `ainvoke`）自動選擇適當的函數。\n\n### 2.3  進階用法\n```python\nfrom langchain.pydantic_v1 import BaseModel, Field\n\nclass NightMarketInput(BaseModel):\n\titem: str = Field(description=\"夜市小吃名稱，例如：蚵仔煎、臭豆腐、珍珠奶茶等\")\n\tquantity: int = Field(description=\"購買數量\")\n\n  \n\ndef calculate_night_market_price(item: str, quantity: int) -> str:\n\t\"\"\"計算台灣夜市小吃的總價。\"\"\"\n\n\tprices = {\n\t\t\"蚵仔煎\": 60,\n\t\t\"臭豆腐\": 40,\n\t\t\"珍珠奶茶\": 50,\n\t\t\"鹽酥雞\": 70,\n\t\t\"大腸包小腸\": 55\n\t}\n\n\tif item not in prices:\n\t\treturn f\"抱歉，我們沒有 {item} 的價格信息。\"\n\ttotal = prices[item] * quantity\n\treturn f\"{quantity} 份 {item} 的總價是 {total} 元新台幣。\"\n\nnight_market_calculator = StructuredTool.from_function(\n\tfunc=calculate_night_market_price,\n\tname=\"台灣夜市小吃計價器\",\n\tdescription=\"計算台灣夜市常見小吃的總價\",\n\targs_schema=NightMarketInput,\n\treturn_direct=True\n)\n\nprint(night_market_calculator.invoke({\"item\": \"蚵仔煎\", \"quantity\": 2}))\nprint(night_market_calculator.name)\nprint(night_market_calculator.description)\nprint(night_market_calculator.args)\n```\n\n\n1. 定義輸入模型：\n\tNightMarketInput 使用 BaseModel 和 Field 定義了輸入參數的結構和描述。\n\t這有助於確保輸入的正確性，並為使用者提供清晰的指引。\n2. 結構化輸入：通過定義明確的輸入模型，可以確保傳入的參數符合預期格式。\n3. 彈性配置：相比 @tool 裝飾器，提供了更多的配置選項。\n4. 同步與非同步支援：可以同時定義同步和非同步版本的函數。\n5. 易於整合：可以輕鬆地與 LangChain 的其他組件（如 Agents）整合。\n---\n## 工具的錯誤處理\n```python\nfrom langchain_core.tools import ToolException\nfrom langchain.tools import StructuredTool\n````\n\n### 3.1 設置 ToolException\n\n並使用 `handle_tool_error` 來指定錯誤處理方式。\n\n可以設置在這裡，該函數直接抱一個 ToolException：\n\n```python\ndef get_weather(city: str) -> int:\n    \"\"\"查詢指定城市的天氣。\"\"\"\n    raise ToolException(f\"錯誤：找不到名為 {city} 的城市。\")\n```\n\n### 3.2 使用 StructuredTool.from_function\n\n```python\nStructuredTool.from_function(\n    func=get_weather,\n    handle_tool_error=True,\n)\n```\n\n也可以直接這樣：\n\n```python\nget_weather_tool = StructuredTool.from_function(\n    func=get_weather,\n    handle_tool_error=\"抱歉，找不到該城市，但那裡的溫度應該高於絕對零度！\",\n)\n\nresult = get_weather_tool.invoke({\"city\": \"未知城市\"})\nprint(\"自定義字串錯誤處理：\", result)\n```\n\n### 3.3 使用自定義函數處理\n\n```python\n# 使用自定義錯誤處理函數\ndef custom_error_handler(error: ToolException) -> str:\n    return f\"工具執行期間發生以下錯誤：`{error.args[0]}`\"\n\nget_weather_tool = StructuredTool.from_function(\n    func=get_weather,\n    handle_tool_error=custom_error_handler,\n)\n\nresult = get_weather_tool.invoke({\"city\": \"未知城市\"})\nprint(\"自定義函數錯誤處理：\", result)\n```",
  "size": 7714,
  "lines": 306
}