{
  "file_id": "7da3a10f",
  "name": "8.4b LangGraph 基本組件.md",
  "path": "8. 人工智能/8.4 Agentic System/8.4b LangGraph 基本組件.md",
  "content": "LangGraph 用有向圖（Directed Graph）來描述應用程式結構。想像將你的應用程式描述成一張有向圖。\n\n他的組件有 \n1. Node \n2. Edge\n3. State\n\n節點(Node) 都代表一個工作站，\n邊(edge) 則是工作站之間傳遞資訊的通道。\nstate 則是消息共享中心\n## **Node節點：**\n工作站\n可以用add_node方法加入到工作流程圖中：\n  \n```python\n\ndef function1(input_1):\n  return input_1 + \" Function1處理完畢\"\n\ndef function2(input_2):\n  return input_2 + \" Function2處理完畢\"\n\ngraph.add_node(\"node_1\", function1)\ngraph.add_node(\"node_2\", function2)\n\n```\n\n### *Chain*\n一般來說，call model 的部分，會先用chain包起來，長得像這樣\n\n``` python\nfrom langchain_openai import ChatOpenAI\nfrom langchain.prompts import ChatPromptTemplate\n\nmodel = ChatOpenAI(temperature=0.4)\nprompt_str = \"\"\"\nYou are given one question and you have to extract city name from it\n\"\"\"\nprompt = ChatPromptTemplate.from_template(prompt_str)\n\n# 這一步，是把 prompt 跟 model 組成 Chain \nchain = prompt | model\nres = chain.invoke({\"user_query\": \"請問高雄天氣如何?\"})\nres.content\n```\n再這樣包成 Node\n\n```python\n\ndef call_model(state: AllState):\n    messages = state[\"messages\"]\n    print(\"messages\", messages)\n    response = chain.invoke(messages)\n    return {\"messages\": [response]}\n\n```\n\n## **Edge 邊：**\n用來連接 Node 的傳送帶\n#### *普通邊(simple Edge)*\n\n```python\n\ngraph.add_edge('node_1', 'node_2')\n\n```\n\n\n####  *入口點(Entry Point)和終點(End Point)*\n\n```python\n\nfrom langgraph.graph import START\nfrom langgraph.graph import END\n\ngraph.add_edge(START, \"node_a\")\ngraph.add_edge(\"node_2\", END)\n\n```\n\n  \n\n#### ***條件邊(Conditional Edge)***\n有條件判斷來執行的邊\n\n```python\n\ndef where_to_go(state):\n  _# Your Logic here_\n  if state['Condition']:\n    return \"end\"\n  else:\n    return \"continue\"\n\n  \n\n# agent node is connected with 2 nodes END and weather_tool_\n\ngraph.add_conditional_edges('agent',where_to_go,{\n    \"end\": END,\n    \"continue\": \"weather_tool\"\n})\n\n```\n\n  \n\n####  ***狀態(state)：消息的共享中心***\n在 LangGraph 中，狀態是捕獲應用程序當前快照的共享資料結構。它可以是任何 Python 類型,但通常是 TypedDict 或 Pydantic BaseModel。\n狀態使節點能夠相互通信和交換訊息。\n\n  \n####  ***圖(Graph): LangGraph 的核心結構***\n有兩種類型的圖可以在 LangGraph 中創建:\n1. 基本圖(Basic Graph): 只能將一個節點的輸出傳遞給下一個節點。因為無法包含狀態\n2. 有狀態圖圖(Stateful Graph): 可以包含在節點之間傳遞的狀態，並且可以在任何節點訪問此狀態。\n\n這裡是如何定義狀態並將其傳遞給有狀態圖的範例:\n\n```python\nimport operator\nfrom typing import TypedDict, Annotated, List\nfrom langgraph.graph import StateGraph\n\n  \nclass AllState(TypedDict):\n    messages: Annotated[list[str], operator.add]\n\ngraph = StateGraph(AllState)\n\n```\n\n  在這個例子中，我們使用 TypedDict 定義了一個包含 messages 鍵的字典。該鍵預期持有一個字符串列表。我們使用 operator.add 函數作為 reducer,這意味著當新消息被添加到列表時,它們將與現有消息組合。\n  \nLangGraph 的核心是將代理工作流程建模為圖，你可以制定你的 AI 代理行為，使用上面介紹的關鍵元素",
  "size": 2452,
  "lines": 135
}