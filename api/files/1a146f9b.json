{
  "file_id": "1a146f9b",
  "name": "8.1b Enhance Context 增強上下文.md",
  "path": "8. 人工智能/8.1 AI服務的組件/8.1b Enhance Context 增強上下文.md",
  "content": "\n## 內容：\n### 觀點\nAI平台的初步擴展通常為添加機制，允許系統為每次query增加必要訊息。上下文相關訊息越多，模型越不用依賴其內部知識，減少幻覺。\n![[Response.png]]\n### 案例\n目前的主要方法為：\n## RAGs(檢索增強生成)\nRAGs的邏輯大致相同，主要差別在檢索器的邏輯，可初步分成\n1. Term-based retrieval\n\t1. BM25(TF-IDF)\n\t2. Elasticsearch\n2. Embedding-based retrieval(vector search)\n\t1. ANN\n\t\t1. FAISS\n\t\t2. _ScaNN_\n\t\t3. ANNOY、_hnswlib_\n\t2. ANN-benchmarks 網站有比較算法，主要看以下四個指標\n\t\t1. Recall 召回率：算法找到的最近鄰的比例。 \n\t\t2. Query per second每秒查詢次數（QPS）：算法每秒可以處理的查詢數量。這對於高流量應用至關重要。 \n\t\t3. Build Time構建時間：構建索引所需的時間。這一指標對於您需要頻繁更新索引（例如，由於數據更改）的情況尤其重要。 \n\t\t4. Index size索引大小：算法創建的索引大小，這對於評估其可擴展性和存儲要求至關重要。\n3. 混合搜尋\n\t1. _Sequential_ 順序檢索，先_Term-based retrieval_，找到後選者，再_Embedding-based retrieval_，從候選者中找最佳的，減少計算成本（ 類似 _pre filter_）\n\t2. Ensemble 集成搜索，將不同方法產生的這些不同的排名結合在一起生成最終的排名\n注意！\n1. 檢索的Documents需要切成 manageable chunks，避免token數過多。\n2. 對Model來說檢索出來的順序，通常不像是傳統搜尋那般重要，有沒有，比順序如何還重要。\n3. 外部的數據可以是結構化的，流程可以是下圖，其中text-to-SQL的那段，可以由模型來負責。\n![[Text-to-.png]]\n\n### 建構 Vector Database 的組件\n[[8.1b1 Chunker]]\n[[8.1b2 Embedding Model]]\n[[8.1b3 Vector Database]]\n\n## Agentic RAGs 代理式RAG\n直接交給瀏覽器來找資料\n1. Google Or Bing API\n\n## Reranker\n可以重新排序回傳的內容，但是，因為有沒有比排序前後還重要。因此非必要。\n\n## Query Rewriting\n1. 重寫使用者的prompt\n2. 可以一樣用模型達成，例如：\n\t![[6-query-rewriting.png]]\n\n但同時也得注意，必須要求模型在不知道，或是資料庫沒資料時，承認問題不可解，或是沒有資料。\n### 總結\n\n\n\n## 參考來源：\nhttps://huyenchip.com/2024/07/25/genai-platform.html#ai_pipeline_orchestration",
  "size": 1332,
  "lines": 55
}